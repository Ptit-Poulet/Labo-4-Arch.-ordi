#include <stdint.h>
#include <stdbool.h>
#include "timer.h"
#include "gpio.h"

/* Timer for LOW and HIGH, I think */
#define PERIPH_BASE        0x3F000000UL
#define INTC_BASE         (PERIPH_BASE + 0x00B200)

#define IRQ_BASIC_PENDING (*(volatile uint32_t*)(INTC_BASE + 0x00))
#define IRQ_PENDING1      (*(volatile uint32_t*)(INTC_BASE + 0x04))
#define IRQ_PENDING2      (*(volatile uint32_t*)(INTC_BASE + 0x08))
#define IRQ_ENABLE1       (*(volatile uint32_t*)(INTC_BASE + 0x10))
#define IRQ_ENABLE2       (*(volatile uint32_t*)(INTC_BASE + 0x14))
#define IRQ_ENABLE_BASIC  (*(volatile uint32_t*)(INTC_BASE + 0x18))
#define IRQ_DISABLE1      (*(volatile uint32_t*)(INTC_BASE + 0x1C))

#define SYS_TIMER_MATCH1_IRQ (1u << 1)

#define SYS_TIMER_BASE    (PERIPH_BASE + 0x003000)
#define TIMER_CS          (*(volatile uint32_t*)(SYS_TIMER_BASE + 0x00))
#define CS_M1             (1u << 1)

#define TICKS_PER_SECOND 100u

static uint32_t tick_count_r = 15u;
static uint32_t tick_count_y = 3u;
static uint32_t tick_count_g = 10u;

typedef enum {GREEN, YELLOW, RED} light_t;
static light_t current_state = GREEN;
static uint32_t ticks_remaining = 0; 


static inline void enter_state(light_t s) {
    current_state = s;
    switch (s) {
        case GREEN:
            gpio_set_green(true);
            gpio_set_yellow(false);
            gpio_set_red(false);
            ticks_remaining = tick_count_g * TICKS_PER_SECOND;
            break;
        case YELLOW:
            gpio_set_green(false);
            gpio_set_yellow(true);
            gpio_set_red(false);
            ticks_remaining = tick_count_y * TICKS_PER_SECOND;
            break;
        case RED:
            gpio_set_green(false);
            gpio_set_yellow(false);
            gpio_set_red(true);
            ticks_remaining = tick_count_r * TICKS_PER_SECOND;
            break;
    }
}

void interrupts_init(void) {
    IRQ_ENABLE1 = SYS_TIMER_MATCH1_IRQ;
    enter_state(GREEN);
}

void irq_handler(void) {
    if (IRQ_PENDING1 & SYS_TIMER_MATCH1_IRQ) {
       if (TIMER_CS & CS_M1) {
        TIMER_CS = CS_M1;         
        if (ticks_remaining > 0) { 
            --ticks_remaining;
        }
        if (ticks_remaining == 0) { 
            switch (current_state) {
                case GREEN:  enter_state(YELLOW); break;
                case YELLOW: enter_state(RED);    break;
                case RED:    enter_state(GREEN);  break;
            }
        }
        timer_schedule_next();    
        }
        return;
    }
}

programme ne fait que l'initialisation des pin puis le case de green une fois puis ce stop.
