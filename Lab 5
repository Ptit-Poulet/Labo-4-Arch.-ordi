#include <stdint.h>
#include <stdbool.h>
#include "timer.h"
#include "gpio.h"

#define PERIPH_BASE        0x3F000000UL
#define INTC_BASE         (PERIPH_BASE + 0x00B200)

#define IRQ_BASIC_PENDING (*(volatile uint32_t*)(INTC_BASE + 0x00))
#define IRQ_PENDING1      (*(volatile uint32_t*)(INTC_BASE + 0x04))
#define IRQ_PENDING2      (*(volatile uint32_t*)(INTC_BASE + 0x08))
#define IRQ_ENABLE1       (*(volatile uint32_t*)(INTC_BASE + 0x10))
#define IRQ_ENABLE2       (*(volatile uint32_t*)(INTC_BASE + 0x14))
#define IRQ_ENABLE_BASIC  (*(volatile uint32_t*)(INTC_BASE + 0x18))
#define IRQ_DISABLE1      (*(volatile uint32_t*)(INTC_BASE + 0x1C))

#define SYS_TIMER_MATCH1_IRQ (1u << 1)

#define SYS_TIMER_BASE    (PERIPH_BASE + 0x003000)
#define TIMER_CS          (*(volatile uint32_t*)(SYS_TIMER_BASE + 0x00))
#define CS_M1             (1u << 1)

/* ====== Set durations here (in ticks) ======
   If your timer tick is 10 ms, use:
     10 s -> 1000, 3 s -> 300, 15 s -> 1500
   If your tick is 1 ms, multiply by 1000 instead, etc.
*/
#define GREEN_TICKS   1000u   /* ~10 s */
#define YELLOW_TICKS  300u    /* ~3 s  */
#define RED_TICKS     1500u   /* ~15 s */

/* ====== minimal additions: enum + targets ====== */
typedef enum { STATE_GREEN, STATE_YELLOW, STATE_RED } light_state_t;
static light_state_t current_state = STATE_GREEN;

static uint32_t tick_count = 0;
static uint32_t target_ticks = GREEN_TICKS;

static inline void drive_outputs(light_state_t s) {
    switch (s) {
        case STATE_GREEN:
            gpio_set_green(true);
            gpio_set_yellow(false);
            gpio_set_red(false);
            break;
        case STATE_YELLOW:
            gpio_set_green(false);
            gpio_set_yellow(true);
            gpio_set_red(false);
            break;
        case STATE_RED:
            gpio_set_green(false);
            gpio_set_yellow(false);
            gpio_set_red(true);
            break;
    }
}

static inline void advance_state(void) {
    switch (current_state) {
        case STATE_GREEN:
            current_state = STATE_YELLOW;
            target_ticks = YELLOW_TICKS;
            break;
        case STATE_YELLOW:
            current_state = STATE_RED;
            target_ticks = RED_TICKS;
            break;
        case STATE_RED:
            current_state = STATE_GREEN;
            target_ticks = GREEN_TICKS;
            break;
    }
    drive_outputs(current_state);
    tick_count = 0;  // just like the original: reset counter on each period end
}

void interrupts_init(void) {
    IRQ_ENABLE1 = SYS_TIMER_MATCH1_IRQ;  // same pattern as original
    // Make outputs valid at startup and preload target
    current_state = STATE_GREEN;
    target_ticks = GREEN_TICKS;
    tick_count = 0;
    drive_outputs(current_state);
}

void irq_handler(void) {
    if (IRQ_PENDING1 & SYS_TIMER_MATCH1_IRQ) {
        if (TIMER_CS & CS_M1) {
            TIMER_CS = CS_M1;      // ack
            tick_count++;          // same style as the original
            if (tick_count >= target_ticks) {
                advance_state();   // move to next light, reload target, reset count
            }
            timer_schedule_next(); // re-arm timer (unchanged)
        }
        return;
    }
}

#####




#include <stdint.h>
#include <stdbool.h>
#include "gpio.h"
#include "uart.h"
/* File to initialise all the pins, I think */
#define PERIPH_BASE      0x3F000000UL
#define GPIO_BASE       (PERIPH_BASE + 0x200000)

#define GPFSEL0         (*(volatile uint32_t*)(GPIO_BASE + 0x00))
#define GPFSEL1         (*(volatile uint32_t*)(GPIO_BASE + 0x04))
#define GPFSEL2         (*(volatile uint32_t*)(GPIO_BASE + 0x08))
#define GPSET0          (*(volatile uint32_t*)(GPIO_BASE + 0x1C))
#define GPCLR0          (*(volatile uint32_t*)(GPIO_BASE + 0x28))

#define PIN_RED         17u
#define PIN_YELLOW      27u
#define PIN_GREEN       22u

static inline void gpio_set_output(uint32_t pin) {
    volatile uint32_t* gpfsel;
    uint32_t shift = (pin % 10u) * 3u;
    if (pin < 10u) gpfsel = &GPFSEL0;
    else if (pin < 20u) gpfsel = &GPFSEL1;
    else gpfsel = &GPFSEL2;
    uint32_t val = *gpfsel;
    val &= ~(0x7u << shift);
    val |=  (0x1u << shift);
    *gpfsel = val;

    uart_debug_gpio_set_output(pin);
}

static inline void gpio_write(uint32_t pin, bool on) {
    if (on) GPSET0 = (1u << pin);
    else    GPCLR0 = (1u << pin);

    uart_debug_gpio_write(pin, on);
}

void gpio_init(void) {
    uart_debug_gpio_init(PIN_RED);
    gpio_set_output(PIN_RED);
    gpio_write(PIN_RED, false);

    uart_debug_gpio_init(PIN_YELLOW);
    gpio_set_output(PIN_YELLOW);
    gpio_write(PIN_YELLOW, false);

    uart_debug_gpio_init(PIN_GREEN);
    gpio_set_output(PIN_GREEN);
    gpio_write(PIN_GREEN, false);
}

void gpio_set_red(bool on)   { gpio_write(PIN_RED, on); }
void gpio_set_yellow(bool on)   { gpio_write(PIN_YELLOW, on); }
void gpio_set_green(bool on)   { gpio_write(PIN_GREEN, on); }


